%This section presents the approach to relation detection using Wikipedia category structure.

%There should be some important sub-sections.

%1. Wikipedia Category Structure

%2. Formalizing the problem of Detecting Relations with Wikipedia Categories

%3. Prominence-base Search: Focusing on Important concepts

%4. Ranking the Class of Entities

%5. Lexical Matching of Categories

%6. Entity Class Disambiguation in Textual Inference

In this section we first give our definitions of ancestor and cousin relationships. After that in section \ref{sec:wikipedia-category-structure}, we describe the Wikipedia category structure. We show that the Wikipedia category structure is naturally fit with the demand of identifying hierarchical relationship between concepts. We then present our algorithms and its extension in sections \ref{sec:algorithms} and \ref{sec:prominence}.

\subsection{Ancestor and Cousin Relationships}
\label{sec:definitions}
We follow the definitions in \cite{Snow2006} to define the hypernym and ($m$, $n$)-cousin relationships between senses in WordNet.
In their paper, a hypernym relationship is denoted by $H_{ij}^{n}$ if a sense $j$ is the $n$-th ancestor of a sense $i$ in the hypernym hiararchy.
The notation is simplified to $H_{ij}$ to denote that sense $j$ is an ancestor of sense $i$ at some level.
On the other hand, the sibling relationship between senses $i$ and $j$ is generalized to ($m$, $n$)-cousin relationship which defines that sense $i$ and sense $j$ have their {\em least common subsummer} (LCS) in within exact $m$ and $n$ links, respectively.

We adopt these definitions to define the ancestor and cousin relationships between entities by using Wikipedia articles and Wikipedia category structure, which we will describe in Section \ref{sec:wikipedia-category-structure}.
We {\em loosely define} that entity $X$ is an ancestor of entity $Y$ if the title of one of the articles about $X$ in Wikipedia {\em matches} one of the categories or ancestor categories of the articles about $Y$ in Wikipedia.
We also follow the ($m$, $n$)-cousinhood definition to define the cousin relationship. Entities $X$ and $Y$ are cousins if the articles about $X$ in Wikipedia {\em share} one or more categories with the articles about $Y$, also in Wikipedia.

For instance, follow our definition, we can verify that {\em color} and {\em red} have an ancestor relationship because there is an article entitled ``Red'' (for entity {\em red}) that belongs to the category {\bf Color} which is the title of another article about entity {\em color}.
We also can verify that {\em red} and {\em green} belong to two articles (one entitled ``Red'', and the other one entitled ``Green'') which share a common caretory {\bf Color}. Therefore, they are cousins.


\subsection{Category Structure of Articles in Wikipedia}
\label{sec:wikipedia-category-structure}
Wikipedia\footnote{http://www.wikipedia.org} is a freely available encyclopedia on the web developed by the contribution of a huge number of internet users around the world. Recently, more and more research that focuses on exploiting the valuable knowledge resources in Wikipedia has been carryied out \cite{CRRS08,richman-schone:2008:ACLMain,suchanek2007WWW,citeulike:2157093}.
There are millions of articles in Wikipedia; and this number is increasing rapidly day by day.
At the time of February, 2009, there are 2,738,772 articles in the English Wikipedia\footnote{http://en.wikipedia.org/wiki/Size\_of\_Wikipedia}.
Each article in this encyclopedia is collaboratively written by volunteers and categorized into different categories by the authors of the article.
One can observe that, although the content of articles in Wikipedia may contain false information at some point in its development, the categories of an article are quite determinable. 

Essentially, as a nature of things, a certain concept may belong to several topics. Similarly, each article in Wikipedia will often be in several categories. And each category itself is also an article in Wikipedia; so it has its own super-categories. For example, the article with the title $t = $ {\em George W. Bush} belongs to a set of categories at the fist level $\mathcal{C}^{1} = $ \{{\em Category:George W. Bush}, {\em Category:Presidents of the United States}, {\em Category:Harvard University alumni}, ...\}; at the second level of $t$ we have
%that $t = $ {\em Category:Presidents of the United States} is in the categories of
$\mathcal{C}^{2} = $ \{{\em Category:Heads of government by country}, {\em Presidents by country}, {\em American politicians}, ...\}.

From the properties of categories, they do not form a strict hierarchy or tree of categories. This allows multiple categorization schemes to co-exist simultaneously. As a guideline in constructing categories of Wikipedia articles, there is no constraints from constructing loops in the category space, but this is strongly discouraged. In our work, we consider the Wikipedia category structure as a directed acyclic graph.

Interestingly, as a matter of fact, articles in the same category or in its sub-categories are considered siblings. This fact is stated clearly in the guideline of the category structure in Wikipedia\footnote{http://en.wikipedia.org/wiki/Wikipedia:Category}. For one who wants to find the siblings of an article, he or she can not only look at the articles in the category but also can find more in its sub-categories. This valuable property of Wikipedia category directly suggests an efficient approach to identify relations between entities as long as they have their own article in Wikipedia.

%\subsection{Identifying Ancestor and Cousin Relationships Using Wikipedia Categories}
\subsection{Identifying Entity Relations Using Wikipedia Categories}
\label{sec:algorithms}

In this section, we present our algorithms for identifying the possible ancestor and cousin relationships between entities.

For any entity $X$, we define the followings variables.

\begin{itemize}
\item $\mathcal{T_{X}}$: the set of the top ranked articles returned by searching $X$ in in the pool of all {\em article titles} in Wikipedia.
\item $\{ c_{t_{X}}^{L} \}$: the set of all categories extracted for the titles $t_{X} \in \mathcal{T_{X}}$ by going up to $L$ levels of ancestor.
\item ${\mathcal C}_{X} = \bigcup_{t_{X} \in {\mathcal T}_{X}} \{{c_{t_{X}}^{L}\}}$: the union set of categories extracted for all titles in $\mathcal{T_{X}}$ by going up to $L$ levels of ancestor.
\end{itemize}

Futthermore, for a category, we can possibly determine its generalized name which we call generalized category, and its domain by analyzing the category using lexical and syntactic information. For instance, with category $c$ = {\em Cities in the United States}, we locate its generalized name as {\em Cities}, and its domain as {\em the United States}. By this, we define the followings variables.

\begin{itemize}
\item ${\mathcal G}_{X}$: the union of all generalized category names of the categories of entity $X$, in ${\mathcal C}_{X}$.
\item ${\mathcal D}_{X}$: the union of all domains of the categories of entity $X$, in ${\mathcal C}_{X}$.
\end{itemize}

\begin{algorithm} [t]
{\small
\caption{AncestorRelationIdentification}
\label{algAncestorIdentifying} 
\begin{algorithmic}[1]
\STATE Input: Wikipedia index $I_{W	}$ 
\STATE $\qquad$$K$: number of top documents 
\STATE $\qquad$$L$: number of levels of ancestor. 
\STATE $\qquad$$(X, Y)$: two input entities. 
\STATE Output: $0$: no ancestor relationship. 
\STATE $\qquad\quad$$1$: $X$ is an ancestor of $Y$.

\STATE ${\mathcal T_{X}}$ $\leftarrow$ SearchByTitle($X$, $I_{W}$, $K$);
\STATE ${\mathcal T_{Y}}$ $\leftarrow$ SearchByTitle($Y$, $I_{W}$, $K$);

\STATE ${\mathcal C}_{Y} = \{\}$;

\FOR{each $t_{Y} \in {\mathcal T}_{Y}$}
\STATE $\{c_{t_{Y}}^{L}\} \leftarrow$ RecursivelyExtractCate$(t_{Y},L)$
\STATE ${\mathcal C}_{Y} = {\mathcal C}_{Y} \cup \{c_{t_{Y}}^{L}\}$;
\ENDFOR

\STATE ${\mathcal G}_{Y} \leftarrow$ CategoryGeneralization$({\mathcal C}_{Y})$;
\STATE ${\mathcal D}_{Y} \leftarrow$ DomainExtraction$({\mathcal C}_{Y})$;

\STATE ${\mathcal E}_{Y} = {\mathcal C}_{Y} \cup {\mathcal G}_{Y} \cup {\mathcal D}_{Y}$

\FOR {each $t \in {\mathcal T_{X}}$}
\IF {(Match $(t,{\mathcal E}_{Y})$)}
\RETURN {1};
\ENDIF
\ENDFOR

\RETURN 0;

\end{algorithmic} 
}
\end{algorithm} 


Algorithm \ref{algAncestorIdentifying} describes our approach to identifying the ancestor relationship between two input entity $X$ and $Y$. The algorithm returns ${\bf 1}$ as an indicator for $X$ to be an ancestor of $Y$. In lines 7 and 8 of the algorithm, we respectively search for articles in Wikipedia that contain all tokens of $X$ and $Y$ in their titles. Only top $K$ most relevant titles are returned. From line 9 to line 13, all categories up to $L$ levels of ancestor of the retrieved articles of $Y$ are collected. We extract the generalized category names and domains of all extracted categories of $Y$ by calling functions {\em CategoryGeneralization} and {\em DomainExtraction}, respectively. After that, from line 16 to 22, the union set ${\mathcal E}_{Y}$ of all categories, their generalized category names, and their domains is produced and compared with the article titles of $X$. If there is any {\em match} happens between titles in ${\mathcal T}_{X}$ and elements in ${\mathcal E}_{Y}$, the algorithm returns the answer indicating that $X$ is an ancestor of $Y$ and terminates, otherwise, the algorithm concludes that there is no ancestor relationship between $X$ and $Y$.

\begin{algorithm} [t]
{\small
\caption{CousinRelationIdentification}
\label{algCousinIdentifying} 
\begin{algorithmic}[1]
\STATE Input: Wikipedia index $I_{W	}$ 
\STATE $\qquad$$K$: number of top documents 
\STATE $\qquad$$L$: number of levels of ancestor. 
\STATE $\qquad$$(X, Y)$: two input entities. 
\STATE Output: $(0,\{\})$: no cousin relationship. 
\STATE $\qquad\quad$$(1,{\mathcal N})$: $X$ and $Y$ are cousin.
\STATE $\quad\qquad$${\mathcal N}$ is the list of possible class names. 

\STATE ${\mathcal T_{X}}$ $\leftarrow$ SearchByTitle($X$, $I_{W}$, $K$);
\STATE ${\mathcal T_{Y}}$ $\leftarrow$ SearchByTitle($Y$, $I_{W}$, $K$);

\STATE ${\mathcal C_{X}}$ $\leftarrow$ CategoryExtraction(${\mathcal T}_{X}$, $L$);
\STATE ${\mathcal C_{Y}}$ $\leftarrow$ CategoryExtraction(${\mathcal T}_{Y}$, $L$);

\STATE ${\mathcal G}_{X} \leftarrow$ CategoryGeneralization$({\mathcal C}_{X})$;
\STATE ${\mathcal G}_{Y} \leftarrow$ CategoryGeneralization$({\mathcal C}_{Y})$;

\STATE ${\mathcal N} = \text{Match}({\mathcal C}_{X}, {\mathcal C}_{Y}) \cup \text{Match}({\mathcal G}_{X}, {\mathcal G}_{Y})$

\IF {(${\mathcal N} \neq \emptyset$)}
\RETURN (1, ${\mathcal N}$);
\ELSE
\RETURN (0, $\{\}$);
\ENDIF

\end{algorithmic} 
}
\end{algorithm} 

The cousin relation identifier is described in Algorithm \ref{algCousinIdentifying}. In lines 8 and 9, the articles in Wikipedia which have the titles containing all words in two entities are retrieved, respectively. After that, the union set of categories are extracted by going upto $L$ levels of ancestor, for all titles in $\mathcal{T_{X}}$, line 10, and $\mathcal{T_{Y}}$, line 11. Function {\em CategoryExtraction} has been actually showed in Algorithm \ref{algAncestorIdentifying} from line 9 to 13. After that, the generalized category names of all extracted categories are induced for $X$ and $Y$. Finally, the matching functions will look for matches between two sets of categories and generalized category names. If there is any match happening, it will be put into a list of all possible class names for $X$ and $Y$. The algorithm is going to return the class name list along with an indicator indicating that $X$ and $Y$ have cousin relationship. Otherwise, it returns {\bf 0} for no relation between $X$ and $Y$.

\begin{algorithm}[t]
{\small
\caption{RelationIdentification}
\label{algRelationIdentifying} 
\begin{algorithmic}[1]
\STATE Input: Wikipedia index $I_{W	}$ 
\STATE $\qquad$$K$: number of top documents 
\STATE $\qquad$$L$: number of levels of ancestor. 
\STATE $\qquad$$(X, Y)$: two input entities. 
\STATE Output: $(0, \{\})$: $X$ and $Y$ have no relationship. 
\STATE $\qquad$$(1, \{\})$: $X$ is an ancestor of $Y$,
\STATE $\qquad$$(2, \{\})$: $Y$ is an ancestor of $X$,
\STATE $\qquad$$(3, {\mathcal N})$: $X$ and $Y$ are cousin,
\STATE $\quad\qquad$${\mathcal N}$ is the list of possible class names. 

\IF {(AncestorRelationIdentification($X$,$Y$))}
\RETURN (1, $\{\}$);
\ELSE
\IF {(AncestorRelationIdentification($Y$, $X$))}
\RETURN  (2, $\{\}$);
\ENDIF
\ENDIF

\STATE $(I, {\mathcal N})$ = CousinRelationIdentification($X$,$Y$)

\IF {($I == 1$)}
\RETURN (3, ${\mathcal N}$);
\ELSE
\RETURN (0, $\{\}$);
\ENDIF

\end{algorithmic} 
}
\end{algorithm} 


After having algorithms to identify ancestor and cousin relations between entities, we design the relation identification algorithm, which is described in Algorithm \ref{algRelationIdentifying}. Input of the algorithm is a pair of entities ($X$, $Y$). The algorithm outputs the predict relationships between $X$ and $Y$, including ancestor, cousin, or no relation. If two entities bind a cousin relationship, the algorithm also returns a list of possible class names of the two entities. For instance, the list of class names would be \{{\em American film actors}, {\em film directors}, ...\} for the input pair ({\em Mel Gibson}, {\em Tom Cruise}). From line 10 to 16, the algorithm first checks if there is ancestor relationship between two entities using Algorithm \ref{algAncestorIdentifying}. The algorithm immediately returns the answer if there is indeed an ancestor relationship between $X$ and $Y$, otherwise, the algorithm continues identifying the possible cousin relationship between two entities. 
Otherwise, the algorithm conclude that there is no relation for two input entities.

% 
%We also define ${\bf I}(\cdot, \cdot)$ as the indicator function that lexically compares two strings and determines whether the two strings are {\em similar}, which will be defined in specific contexts.

%\begin{equation}
%  {\bf I}(u,v) = \begin{cases}
%    1 & \mbox{if $u$ and $v$ are similar} \\
%    0 & \mbox{otherwise}
%    \end{cases}
%    \label{eq:thetaDefinition}
%\end{equation}

%The string arguments of function $f$ can be entities, article titles, categories, generalized names of categories, or domains of categories.

%An entity $X$ is considered a parent of an entity $Y$ if ${\bf I}(X,Y) = 0$ and one of the following conditions is satisfied.

%\begin{itemize}
%\item ${\bf I}(X, c_{Y}) = 1$, where $c_{Y} \in \mathcal{C}_{Y}^{*}$
%\item ${\bf I}(X, g_{Y}) = 1$, where $g_{Y} \in \mathcal{G}_{Y}^{*}$
%\item ${\bf I}(X, d_{Y}) = 1$, where $g_{Y} \in \mathcal{D}_{Y}^{*}$
%\end{itemize}

%Similarly, an entity $X$ is considered a child of an entity $Y$ if ${\bf I}(X,Y) = 0$ and one of the following conditions is satisfied.

%\begin{itemize}
%\item ${\bf I}(c_{X}, Y) = 1$, where $c_{X} \in \mathcal{C}_{X}^{*}$
%\item ${\bf I}(g_{X}, Y) = 1$, where $g_{Y} \in \mathcal{G}_{X}^{*}$
%\item ${\bf I}(d_{X}, Y) = 1$, where $g_{Y} \in \mathcal{D}_{X}^{*}$
%\end{itemize}

%Furthermore, two entities $X$ and $Y$ are considered siblings if ${\bf I}(X,Y) = 0$ and one of the following conditions is satisfied.

%\begin{itemize}
%\item ${\bf I}(c_{X}, c_{Y}) = 1$, where $c_{X} \in \mathcal{C}_{X}^{*}$, and $c_{Y} \in \mathcal{C}_{Y}^{*}$
%\item ${\bf I}(g_{X}, g_{Y}) = 1$, where $g_{X} \in \mathcal{G}_{X}^{*}$, and $g_{Y} \in \mathcal{G}_{Y}^{*}$
%\end{itemize}

%If two entities are determined siblings, their class will be defined by the matched category or matched generalized name.

%\mnote{[QD:] I think this issue can be solved by using WordNet to look up the level of abstraction of the class. In WordNet, the closer a noun to the root node {\bf entity}, the more abstract it is.}

%There is a potential issue with the determined class of two sibling entities. The class can be very abstract, or very specific. Generally, one does not want two entities to be siblings in a very abstract class. XXXXXXXXXXXXXXXXXXXXXXXXXXX to be continue!!!

\subsection{Prominence-based Search}
\label{sec:prominence}
As far as we observe the algorithms, we can see that the {\em SearchByTitle} function guide the identification prediction heavily. If the function returns irrelevant or unimportant articles about entities, we easily get wrong relations. Therefore, designing a good entity search function is important. In this section, we propose an approach called prominence-based search to improve the search results of input entities. Although our initial approach for prominence-based search is simple, it can serve as an disambiguation tool for entities.

We guide the search engine based on an assumption that, without special purpose, people often want to see information known or important entities retrieved when they search for information. We translate this assumption into our search engine by returning only top relevant articles about prominent entities. We measure the prominence of entities by their occurrence in a large text collection. For instance, if one wants to search for entity {\em bush}, the search engine may retrieve thousands of articles including {\em Kate Bush}, {\em William Bush}, {\em Laura Bush}, {\em George W. Bush}, {\em Bush family}, and so on. Among these articles, our system retrieves the ones about {\em George W. Bush}, {\em George H. W. Bush} in the top of the returned article set because their frequency of occurrence dominates other entities.
%Algorithm \ref{alg:prominence-search} present our approach to prominence-based search.

%\begin{algorithm}[t]
%\caption{Prominence-based Search}
%\label{alg:prominence-search} 
%\begin{algorithmic}[1]
%\STATE Input: an entity $X$. 
%\STATE $\qquad$$K$: number of top ranked articles. 
%\STATE $\qquad$${\mathcal D}$: a document collection
%\STATE Output: A ranked list of articles about $X$ based on prominency. 

%\STATE ${\mathcal T}_{X} \leftarrow $ NormalSearchByTitle($X$);
%\STATE ${\mathcal T}$ = \{\};

%\FOR {each $t \in {\mathcal T}_{X}$}
%\STATE $hit = \text{HitCount}(t, {\mathcal D})$;
%\STATE ${\mathcal T} \leftarrow \left< t, hit \right>$;
%\ENDFOR

%\STATE ${\mathcal T} \leftarrow \text{SortByProminence}({\mathcal T})$;

%\RETURN Top $K$ articles from ${\mathcal T}$;

%\end{algorithmic} 
%\end{algorithm} 


%\subsection{The Association of a Title and its Category}

%\subsection{The Issue of Redirect Articles}

%\subsection{Lexical Similarity Matching}

